<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>第二章-写的都是看到的——面向对象编程</title>
</head>
<body>
    <pre>
        1、每个类有3个部分：
           第一部分是构造函数内的，这是供实例化对象复制用的
           第二部分是构造函数外的，通过点语法添加，这是供类使用的，实例化队形是访问不到的
           第三部分是类的原型中的，实例化对象可以通过其原型链间接的访问到，这是供所有实例化对象共用的
        2、类式继承：需要将第一个类的实例赋值给第二个类的原型  prototype = new SuperClass()
                   缺点一：子类通过其原型prototype对父类实例化，继承了父类，所以说父类中的共有属性要是引用类型，就会在子类中被所有实例公用
                   缺点二：子类实现的继承是靠其原型对象对父类实例化实现的，因此在继承父类的时候，
                          是无法向其父类传递参数的，因而在实例化父类的时候也无法对其父类构造函数内的属性进行初始化
        3、instanceof 是判断前面的对象是否是后面的实例
        4、函数式继承：SuperClass.call(this,id)，这条语句是函数式继承的精华。(通过在子类的构造函数作用环境中执行一次父类的构造函数实现)
                     由于call可以更改函数的作用环境，因此在子类中，对spuperClass的调用这个方法就是将子类中的变量在父类中执行一遍，
                    由于父类中是给this绑定属性的，因此子类就也继承了父类的共有属性。
                    缺点：但是，无法继承父类的原型prototype的方法
        5、组合继承：
                 缺点：在使用构造函数继承时执行了一遍父类的构造函数，
                      在实现子类原型的类式继承时又调用了一遍父类构造函数。
        6、原型式继承：过渡对象相当于类式继承的子类，目的是为了创建要返回的新的实例化对象   
                缺点：跟类式继承一样，引用型值被复制，导致污染变化
        7、寄生式继承：对原型继承的第二次封装，并且在这第二次封装的过程中对继承的对象进行了拓展，这样新创建的对象不仅仅有父类中的属性和方法，而且还添加新的属性和方法
        8、寄生组合式继承：对子类型原型的处理不同，被赋予父类原型的一个引用
                注意：子类再想添加原型方法必须通过prototype.对象，否则直接赋值会覆盖掉父类原型继承的对象


    关联：寄生是寄生式继承，寄生式继承依托于原型继承，原型继承类似于类式继承
    浅复制：只能复制值类型的属性，对于一弄类型属性无能为力
    多态：就是同一个方法多种调用方式吧
    </pre>
    <script src="./2toOjecct.js"></script>
</body>
</html>